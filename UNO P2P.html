<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P Uno</title>
    <style>
        :root { --bg-color: #2c3e50; --card-w: 80px; --card-h: 120px; }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg-color); color: white; display: flex; flex-direction: column; align-items: center; margin: 0; height: 100vh; overflow: hidden; }
        
        /* SCREENS */
        #lobby-screen, #game-screen { width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .hidden { display: none !important; }

        /* UI ELEMENTS */
        input { padding: 10px; border-radius: 5px; border: none; font-size: 1.2rem; text-align: center; margin-bottom: 10px; }
        button { padding: 10px 20px; background: #27ae60; color: white; border: none; border-radius: 5px; font-size: 1.2rem; cursor: pointer; transition: 0.2s; margin: 5px; }
        button:hover { transform: scale(1.05); }
        button:disabled { background: #7f8c8d; cursor: not-allowed; }

        /* GAME BOARD */
        #opponents { display: flex; gap: 20px; margin-top: 20px; height: 100px; align-items: center; }
        .opponent { background: rgba(0,0,0,0.3); padding: 10px; border-radius: 10px; text-align: center; }
        .opponent.active { border: 2px solid yellow; box-shadow: 0 0 15px yellow; }

        #table-center { flex-grow: 1; display: flex; align-items: center; justify-content: center; gap: 40px; }
        
        #my-hand { display: flex; gap: -20px; margin-bottom: 20px; overflow-x: auto; padding: 20px; max-width: 90%; align-items: flex-end; height: 140px; }
        
        /* CARDS */
        .card {
            width: var(--card-w); height: var(--card-h);
            background: white; border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 24px;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.5);
            cursor: pointer; user-select: none; position: relative;
            border: 4px solid white;
            transition: transform 0.2s;
        }
        .card:hover { transform: translateY(-15px) scale(1.1); z-index: 10; }
        
        .card.red { background: #e74c3c; color: white; }
        .card.blue { background: #3498db; color: white; }
        .card.green { background: #2ecc71; color: white; }
        .card.yellow { background: #f1c40f; color: black; }
        .card.black { background: #2c3e50; color: white; border: 2px solid white; }
        
        .card-back { background: linear-gradient(45deg, #000, #444); color: transparent; }
        
        .deck-pile { cursor: pointer; }
        .turn-indicator { position: absolute; top: 10px; right: 10px; font-size: 0.8rem; background: #e67e22; padding: 5px; border-radius: 4px; }

        #status-msg { font-size: 1.5rem; font-weight: bold; margin-bottom: 10px; color: #f39c12; height: 30px; }
    </style>
</head>
<body>

    <div id="lobby-screen">
        <h1>P2P UNO</h1>
        <p>Enter a Room Name to join others.</p>
        <input type="text" id="room-input" placeholder="e.g. pizza" value="uno-room">
        <button id="join-btn">Join Room</button>
        <div id="lobby-status" class="hidden">
            <p>Waiting for players...</p>
            <p id="player-count">Players: 1</p>
            <button id="start-btn" class="hidden">START GAME (Host)</button>
        </div>
    </div>

    <div id="game-screen" class="hidden">
        <div id="opponents">
            </div>
        
        <div id="status-msg"></div>

        <div id="table-center">
            <div class="card card-back deck-pile" onclick="clientDrawCard()">
                UNO
            </div>
            <div id="discard-pile">
                </div>
        </div>

        <div id="my-hand">
            </div>
    </div>

    <script type="module">
        // IMPORT TRYSTERO (P2P Library)
        import { joinRoom, selfId } from 'https://esm.sh/trystero/torrent';

        // --- VARIABLES ---
        let config = { appId: 'simple-uno-v1' };
        let room, sendAction, getAction, sendState, getState;
        let myId = selfId;
        let peers = [];
        
        // STATE
        let isHost = false;
        let gameState = {
            status: 'LOBBY',
            players: {}, // { peerId: { name: "Player", hand: [] } }
            order: [],
            turnIndex: 0,
            direction: 1,
            deck: [],
            discard: null
        };

        // --- LOBBY LOGIC ---
        document.getElementById('join-btn').onclick = () => {
            const roomId = document.getElementById('room-input').value;
            if(!roomId) return alert("Enter room name");
            
            // Init P2P
            room = joinRoom(config, roomId);
            [sendAction, getAction] = room.makeAction('action');
            [sendState, getState] = room.makeAction('state');

            // Update UI
            document.getElementById('join-btn').classList.add('hidden');
            document.getElementById('room-input').classList.add('hidden');
            document.getElementById('lobby-status').classList.remove('hidden');

            // Setup Listeners
            setupNetwork();
            
            // Add myself to player list locally (Host logic will consolidate later)
            peers.push(myId);
            updateLobbyUI();

            // Check if I should be host (Logic: if no state received in 2s, I am host)
            setTimeout(() => {
                if(!gameState.deck.length && !isHost) {
                    document.getElementById('start-btn').classList.remove('hidden');
                    document.getElementById('start-btn').onclick = startGameAsHost;
                }
            }, 1500);
        };

        function setupNetwork() {
            room.onPeerJoin(peerId => {
                console.log("Peer joined:", peerId);
                peers.push(peerId);
                updateLobbyUI();
                if(isHost) broadcastState();
            });

            room.onPeerLeave(peerId => {
                peers = peers.filter(p => p !== peerId);
                updateLobbyUI();
            });

            // RECEIVE STATE (Clients)
            getState((state) => {
                gameState = state;
                // If game started, switch screens
                if(gameState.status === 'PLAYING') {
                    document.getElementById('lobby-screen').classList.add('hidden');
                    document.getElementById('game-screen').classList.remove('hidden');
                    renderGame();
                }
            });

            // RECEIVE ACTIONS (Host)
            getAction((data, peerId) => {
                if(!isHost) return;
                handleGameAction(data, peerId);
            });
        }

        function updateLobbyUI() {
            document.getElementById('player-count').innerText = `Players: ${peers.length}`;
        }

        // --- HOST GAME ENGINE ---

        function startGameAsHost() {
            isHost = true;
            gameState.status = 'PLAYING';
            gameState.order = [...peers]; // Simple turn order
            gameState.players = {};
            
            // Generate Deck
            const colors = ['red', 'blue', 'green', 'yellow'];
            const values = ['0','1','2','3','4','5','6','7','8','9','SKIP','REV','+2'];
            let deck = [];
            
            colors.forEach(c => {
                values.forEach(v => {
                    deck.push({ color: c, value: v, uid: Math.random() });
                    if(v !== '0') deck.push({ color: c, value: v, uid: Math.random() });
                });
            });
            
            // Shuffle
            gameState.deck = deck.sort(() => Math.random() - 0.5);

            // Deal
            gameState.order.forEach(pid => {
                gameState.players[pid] = { hand: [] };
                for(let i=0; i<7; i++) gameState.players[pid].hand.push(gameState.deck.pop());
            });

            // Start Pile
            gameState.discard = gameState.deck.pop();
            // Ensure first card isn't a wild/special for simplicity
            while(['SKIP','REV','+2'].includes(gameState.discard.value)) {
                gameState.deck.push(gameState.discard); // put back
                gameState.deck.sort(() => Math.random() - 0.5);
                gameState.discard = gameState.deck.pop();
            }

            broadcastState();
        }

        function handleGameAction(action, peerId) {
            // Security: Is it this player's turn?
            const currentPlayer = gameState.order[gameState.turnIndex];
            if (peerId !== currentPlayer) return;

            if (action.type === 'DRAW') {
                const card = gameState.deck.pop();
                if(!card) { recycleDeck(); } // Handle empty deck
                gameState.players[peerId].hand.push(card || gameState.deck.pop());
                nextTurn(false); 
            }
            
            if (action.type === 'PLAY') {
                const cardIndex = action.index;
                const card = gameState.players[peerId].hand[cardIndex];
                const top = gameState.discard;

                // Validate
                if (card.color === top.color || card.value === top.value) {
                    // Move card
                    gameState.discard = card;
                    gameState.players[peerId].hand.splice(cardIndex, 1);
                    
                    // Special Effects
                    let skip = false;
                    if (card.value === 'SKIP') skip = true;
                    if (card.value === 'REV') gameState.direction *= -1;
                    if (card.value === '+2') {
                        // Give next player 2 cards
                        let nextP = getNextPlayerIndex();
                        let victimId = gameState.order[nextP];
                        gameState.players[victimId].hand.push(gameState.deck.pop(), gameState.deck.pop());
                        skip = true; // Usually +2 skips turn
                    }

                    // Win Check
                    if (gameState.players[peerId].hand.length === 0) {
                        gameState.winner = peerId;
                        gameState.status = 'GAME_OVER';
                    } else {
                        nextTurn(skip);
                    }
                }
            }
            
            broadcastState();
        }

        function nextTurn(skip) {
            let step = gameState.direction;
            if (skip) step *= 2;
            gameState.turnIndex = (gameState.turnIndex + step) % gameState.order.length;
            if (gameState.turnIndex < 0) gameState.turnIndex += gameState.order.length;
        }

        function getNextPlayerIndex() {
            let idx = (gameState.turnIndex + gameState.direction) % gameState.order.length;
            if (idx < 0) idx += gameState.order.length;
            return idx;
        }

        function recycleDeck() {
            // Simple recycle (omitted for brevity, usually shuffle discard into deck)
        }

        function broadcastState() {
            sendState(gameState);
            // Host needs to update their own UI too
            if(gameState.status === 'PLAYING') {
                document.getElementById('lobby-screen').classList.add('hidden');
                document.getElementById('game-screen').classList.remove('hidden');
                renderGame();
            }
        }

        // --- CLIENT UI RENDER ---
        
        window.clientDrawCard = function() {
            sendAction({ type: 'DRAW' });
        }

        window.clientPlayCard = function(index) {
            sendAction({ type: 'PLAY', index: index });
        }

        function renderGame() {
            // 1. Render Status
            const currentTurnId = gameState.order[gameState.turnIndex];
            const statusDiv = document.getElementById('status-msg');
            
            if(gameState.status === 'GAME_OVER') {
                statusDiv.innerText = (gameState.winner === myId ? "YOU WON!" : "YOU LOST!");
                return;
            }

            statusDiv.innerText = (currentTurnId === myId) ? "YOUR TURN" : "Waiting for opponent...";

            // 2. Render Discard Pile
            const discardDiv = document.getElementById('discard-pile');
            discardDiv.innerHTML = renderCardHTML(gameState.discard);

            // 3. Render My Hand
            const myHandDiv = document.getElementById('my-hand');
            myHandDiv.innerHTML = '';
            const myHand = gameState.players[myId].hand;
            
            myHand.forEach((card, index) => {
                const el = document.createElement('div');
                el.innerHTML = renderCardHTML(card);
                el.onclick = () => clientPlayCard(index);
                myHandDiv.appendChild(el.firstChild);
            });

            // 4. Render Opponents
            const oppDiv = document.getElementById('opponents');
            oppDiv.innerHTML = '';
            gameState.order.forEach(pid => {
                if(pid === myId) return;
                const count = gameState.players[pid].hand.length;
                const isActive = (pid === currentTurnId);
                oppDiv.innerHTML += `
                    <div class="opponent ${isActive ? 'active' : ''}">
                        <div>P${pid.substr(0,4)}</div>
                        <div style="font-size:20px">ðŸŽ´ ${count}</div>
                    </div>
                `;
            });
        }

        function renderCardHTML(card) {
            return `<div class="card ${card.color}">
                ${card.value}
            </div>`;
        }

    </script>
</body>
</html>