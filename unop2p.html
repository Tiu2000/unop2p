<script type="module">
        import { joinRoom, selfId } from 'https://esm.sh/trystero/torrent';

        // --- VARIABLES ---
        let config = { appId: 'simple-uno-v2' }; // Changed ID to reset cache
        let room, sendAction, getAction, sendState, getState;
        let myId = selfId;
        let peers = []; // All connected IDs including me
        
        // STATE
        let isHost = false;
        let gameState = {
            status: 'LOBBY',
            players: {}, 
            order: [],
            turnIndex: 0,
            direction: 1,
            deck: [],
            discard: null,
            winner: null
        };

        // --- LOBBY LOGIC ---
        document.getElementById('join-btn').onclick = () => {
            const roomId = document.getElementById('room-input').value;
            if(!roomId) return alert("Enter room name");
            
            room = joinRoom(config, roomId);
            [sendAction, getAction] = room.makeAction('action');
            [sendState, getState] = room.makeAction('state');

            // UI Updates
            document.getElementById('join-btn').classList.add('hidden');
            document.getElementById('room-input').classList.add('hidden');
            document.getElementById('lobby-status').classList.remove('hidden');

            setupNetwork();
            
            // Add self to peer list
            peers.push(myId);
            updateLobbyUI();

            // Host Election: If no state received in 2s, assume Host
            setTimeout(() => {
                if(gameState.status === 'LOBBY' && !isHost && peers.length === 1) {
                    document.getElementById('start-btn').classList.remove('hidden');
                    document.getElementById('start-btn').onclick = startGameAsHost;
                }
            }, 2000);
        };

        function setupNetwork() {
            room.onPeerJoin(peerId => {
                console.log("Peer joined:", peerId);
                if(!peers.includes(peerId)) peers.push(peerId);
                updateLobbyUI();
                
                // If I am host, I must welcome them with the current state
                if(isHost) broadcastState();
            });

            room.onPeerLeave(peerId => {
                peers = peers.filter(p => p !== peerId);
                updateLobbyUI();
            });

            getState((state) => {
                // If I receive state, I am NOT the host (or I'm syncing)
                gameState = state;
                if(gameState.status === 'PLAYING' || gameState.status === 'GAME_OVER') {
                    switchScreen('game');
                    renderGame();
                }
            });

            getAction((data, peerId) => {
                if(!isHost) return; // Only Host processes actions
                handleGameAction(data, peerId);
            });
        }

        function updateLobbyUI() {
            document.getElementById('player-count').innerText = `Players: ${peers.length}`;
        }

        function switchScreen(screen) {
            if(screen === 'game') {
                document.getElementById('lobby-screen').classList.add('hidden');
                document.getElementById('game-screen').classList.remove('hidden');
            }
        }

        // --- HOST GAME ENGINE ---

        function startGameAsHost() {
            isHost = true;
            gameState.status = 'PLAYING';
            // Ensure order is randomized or based on join order
            gameState.order = [...peers]; 
            
            // Generate Deck
            const colors = ['red', 'blue', 'green', 'yellow'];
            const values = ['0','1','2','3','4','5','6','7','8','9','SKIP','REV','+2'];
            let deck = [];
            
            colors.forEach(c => {
                values.forEach(v => {
                    deck.push({ color: c, value: v, uid: Math.random() });
                    if(v !== '0') deck.push({ color: c, value: v, uid: Math.random() });
                });
            });
            
            gameState.deck = deck.sort(() => Math.random() - 0.5);

            // Deal
            gameState.players = {};
            gameState.order.forEach(pid => {
                gameState.players[pid] = { hand: [] };
                for(let i=0; i<7; i++) gameState.players[pid].hand.push(gameState.deck.pop());
            });

            // Start Pile
            gameState.discard = gameState.deck.pop();
            // Simple check to ensure first card is valid
            while(!gameState.discard) {
                gameState.discard = gameState.deck.pop();
            }

            broadcastState();
        }

        function handleGameAction(action, peerId) {
            const currentPlayer = gameState.order[gameState.turnIndex];
            
            // Validation: Is it their turn?
            if (peerId !== currentPlayer) {
                console.log(`Ignored action from ${peerId} (Not their turn)`);
                return;
            }

            if (action.type === 'DRAW') {
                const card = gameState.deck.pop();
                if(card) {
                    gameState.players[peerId].hand.push(card);
                }
                // Drawing passes turn immediately in this simple version
                nextTurn(false); 
            }
            
            if (action.type === 'PLAY') {
                const cardIndex = action.index;
                const playerHand = gameState.players[peerId].hand;
                
                // Bounds check
                if(!playerHand[cardIndex]) return;

                const card = playerHand[cardIndex];
                const top = gameState.discard;

                // Game Rules
                if (card.color === top.color || card.value === top.value) {
                    gameState.discard = card;
                    playerHand.splice(cardIndex, 1);
                    
                    // Special Cards
                    let skip = false;
                    if (card.value === 'SKIP') skip = true;
                    if (card.value === 'REV') gameState.direction *= -1;
                    if (card.value === '+2') {
                        let nextP = getNextPlayerIndex();
                        let victimId = gameState.order[nextP];
                        // Safety check if deck runs out
                        if(gameState.deck.length > 2) {
                            gameState.players[victimId].hand.push(gameState.deck.pop(), gameState.deck.pop());
                        }
                        skip = true; 
                    }

                    // Win Condition
                    if (playerHand.length === 0) {
                        gameState.winner = peerId;
                        gameState.status = 'GAME_OVER';
                    } else {
                        nextTurn(skip);
                    }
                }
            }
            
            broadcastState();
        }

        function nextTurn(skip) {
            let step = gameState.direction;
            if (skip) step *= 2; // Jump over next player
            
            gameState.turnIndex = (gameState.turnIndex + step) % gameState.order.length;
            
            // Handle JavaScript negative modulo bug
            if (gameState.turnIndex < 0) gameState.turnIndex += gameState.order.length;
        }

        function getNextPlayerIndex() {
            let idx = (gameState.turnIndex + gameState.direction) % gameState.order.length;
            if (idx < 0) idx += gameState.order.length;
            return idx;
        }

        function broadcastState() {
            sendState(gameState);
            // HOST LOCAL UPDATE
            if(isHost) {
                switchScreen('game');
                renderGame();
            }
        }

        // --- CLIENT UI RENDER ---
        
        // ** THE FIX IS HERE **
        window.clientDrawCard = function() {
            if(isHost) {
                handleGameAction({ type: 'DRAW' }, myId);
            } else {
                sendAction({ type: 'DRAW' });
            }
        }

        window.clientPlayCard = function(index) {
            if(isHost) {
                handleGameAction({ type: 'PLAY', index: index }, myId);
            } else {
                sendAction({ type: 'PLAY', index: index });
            }
        }

        function renderGame() {
            // Winner Screen
            if(gameState.status === 'GAME_OVER') {
                document.getElementById('status-msg').innerText = 
                    (gameState.winner === myId ? "ðŸ† YOU WON! ðŸ†" : "âŒ YOU LOST! âŒ");
                document.getElementById('table-center').classList.add('hidden');
                return;
            }

            // Turn Indicator
            const currentTurnId = gameState.order[gameState.turnIndex];
            const isMyTurn = (currentTurnId === myId);
            const statusDiv = document.getElementById('status-msg');
            statusDiv.innerText = isMyTurn ? "ðŸŸ¢ YOUR TURN" : `ðŸ”´ Waiting for Player...`;

            // Deck & Discard
            document.getElementById('discard-pile').innerHTML = renderCardHTML(gameState.discard);

            // My Hand
            const myHandDiv = document.getElementById('my-hand');
            myHandDiv.innerHTML = '';
            
            // Safety check: ensure my hand exists in state
            const myData = gameState.players[myId];
            if(myData && myData.hand) {
                myData.hand.forEach((card, index) => {
                    const el = document.createElement('div');
                    el.innerHTML = renderCardHTML(card);
                    // Only allow clicking if it's my turn
                    if(isMyTurn) {
                        el.onclick = () => clientPlayCard(index);
                        el.style.cursor = "pointer";
                    } else {
                        el.style.opacity = "0.7";
                        el.style.cursor = "not-allowed";
                    }
                    myHandDiv.appendChild(el.firstChild);
                });
            }

            // Opponents
            const oppDiv = document.getElementById('opponents');
            oppDiv.innerHTML = '';
            gameState.order.forEach(pid => {
                if(pid === myId) return;
                const pData = gameState.players[pid];
                const count = pData ? pData.hand.length : 0;
                const isActive = (pid === currentTurnId);
                
                oppDiv.innerHTML += `
                    <div class="opponent ${isActive ? 'active' : ''}">
                        <div>Player</div>
                        <div style="font-size:20px">ðŸŽ´ ${count}</div>
                    </div>
                `;
            });
        }

        function renderCardHTML(card) {
            if(!card) return '';
            return `<div class="card ${card.color}">
                ${card.value}
            </div>`;
        }
    </script>
