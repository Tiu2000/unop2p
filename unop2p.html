<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P Uno - Final</title>
    <style>
        :root { --bg-color: #2c3e50; --card-w: 80px; --card-h: 120px; }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg-color); color: white; display: flex; flex-direction: column; align-items: center; margin: 0; height: 100vh; overflow: hidden; user-select: none; }
        
        #lobby-screen, #game-screen { width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .hidden { display: none !important; }

        input { padding: 10px; border-radius: 5px; border: none; font-size: 1.2rem; text-align: center; margin-bottom: 10px; }
        button { padding: 10px 20px; background: #27ae60; color: white; border: none; border-radius: 5px; font-size: 1.2rem; cursor: pointer; margin: 5px; }
        button:hover { transform: scale(1.05); }

        #opponents { display: flex; gap: 20px; margin-top: 20px; height: 100px; align-items: center; }
        .opponent { background: rgba(0,0,0,0.3); padding: 10px; border-radius: 10px; text-align: center; opacity: 0.7; }
        .opponent.active { border: 2px solid #f1c40f; box-shadow: 0 0 15px #f1c40f; opacity: 1; transform: scale(1.1); transition: 0.3s; }

        #table-center { flex-grow: 1; display: flex; align-items: center; justify-content: center; gap: 40px; }
        
        #my-hand { display: flex; gap: -30px; margin-bottom: 20px; overflow-x: auto; padding: 20px; max-width: 90%; align-items: flex-end; height: 150px; }
        
        /* CARD STYLES */
        .card {
            width: var(--card-w); height: var(--card-h);
            background: white; border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            font-weight: 900; font-size: 28px;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.5);
            border: 4px solid white;
            transition: transform 0.2s, opacity 0.2s;
            position: relative;
            text-shadow: 1px 1px 0px rgba(0,0,0,0.2);
        }
        
        .card.red { background: #e74c3c; color: white; }
        .card.blue { background: #3498db; color: white; }
        .card.green { background: #2ecc71; color: white; }
        .card.yellow { background: #f1c40f; color: black; }
        
        .card-back { background: linear-gradient(135deg, #2c3e50 25%, #34495e 25%, #34495e 50%, #2c3e50 50%, #2c3e50 75%, #34495e 75%, #34495e 100%); background-size: 20px 20px; border: 4px solid white; }
        
        .deck-pile { cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; color: transparent; }
        
        #status-msg { font-size: 1.5rem; font-weight: bold; margin-bottom: 10px; color: #f39c12; height: 30px; }
    </style>
</head>
<body>

    <div id="lobby-screen">
        <h1>P2P UNO</h1>
        <input type="text" id="room-input" placeholder="e.g. pizza" value="uno-room">
        <button id="join-btn">Join Room</button>
        <div id="lobby-status" class="hidden">
            <p>Waiting for players...</p>
            <p id="player-count">Players: 1</p>
            <button id="start-btn" class="hidden">START GAME</button>
        </div>
    </div>

    <div id="game-screen" class="hidden">
        <div id="opponents"></div>
        <div id="status-msg"></div>

        <div id="table-center">
            <div class="card card-back deck-pile" onclick="clientDrawCard()">UNO</div>
            <div id="discard-pile"></div>
        </div>

        <div id="my-hand"></div>
    </div>

    <script type="module">
        import { joinRoom, selfId } from 'https://esm.sh/trystero/torrent';

        // CONFIG
        let config = { appId: 'uno-v4-final' }; 
        let room, sendAction, getAction, sendState, getState;
        let myId = selfId;
        let peers = []; 
        let isHost = false;

        // GAME STATE
        let gameState = {
            status: 'LOBBY',
            players: {}, 
            order: [],
            turnIndex: 0,
            direction: 1,
            deck: [],
            discardPile: [],
            winner: null
        };

        // --- LOBBY ---
        document.getElementById('join-btn').onclick = () => {
            const roomId = document.getElementById('room-input').value;
            if(!roomId) return alert("Enter room name");
            
            room = joinRoom(config, roomId);
            [sendAction, getAction] = room.makeAction('action');
            [sendState, getState] = room.makeAction('state');

            document.getElementById('join-btn').classList.add('hidden');
            document.getElementById('room-input').classList.add('hidden');
            document.getElementById('lobby-status').classList.remove('hidden');

            setupNetwork();
            peers.push(myId);
            updateLobbyUI();

            setTimeout(() => {
                if(gameState.status === 'LOBBY' && !isHost && peers.length === 1) {
                    document.getElementById('start-btn').classList.remove('hidden');
                    document.getElementById('start-btn').onclick = startGameAsHost;
                }
            }, 2000);
        };

        function setupNetwork() {
            room.onPeerJoin(peerId => {
                if(!peers.includes(peerId)) peers.push(peerId);
                updateLobbyUI();
                if(isHost) broadcastState();
            });
            room.onPeerLeave(peerId => {
                peers = peers.filter(p => p !== peerId);
                updateLobbyUI();
            });
            getState((state) => {
                gameState = state;
                if(gameState.status === 'PLAYING' || gameState.status === 'GAME_OVER') {
                    switchScreen('game');
                    renderGame();
                }
            });
            getAction((data, peerId) => {
                if(isHost) handleGameAction(data, peerId);
            });
        }

        function updateLobbyUI() {
            document.getElementById('player-count').innerText = `Players: ${peers.length}`;
        }
        function switchScreen(screen) {
            if(screen === 'game') {
                document.getElementById('lobby-screen').classList.add('hidden');
                document.getElementById('game-screen').classList.remove('hidden');
            }
        }

        // --- HOST LOGIC ---
        function startGameAsHost() {
            isHost = true;
            gameState.status = 'PLAYING';
            gameState.order = [...peers]; 
            
            const colors = ['red', 'blue', 'green', 'yellow'];
            const values = ['0','1','2','3','4','5','6','7','8','9','SKIP','REV','+2'];
            let deck = [];
            colors.forEach(c => {
                values.forEach(v => {
                    deck.push({ color: c, value: v, uid: Math.random() });
                    if(v !== '0') deck.push({ color: c, value: v, uid: Math.random() });
                });
            });
            gameState.deck = deck.sort(() => Math.random() - 0.5);

            gameState.players = {};
            gameState.order.forEach(pid => {
                gameState.players[pid] = { hand: [] };
                for(let i=0; i<7; i++) gameState.players[pid].hand.push(gameState.deck.pop());
            });

            gameState.discardPile = [gameState.deck.pop()];
            while(['SKIP','REV','+2'].includes(gameState.discardPile[0].value)) {
                gameState.deck.push(gameState.discardPile.pop());
                gameState.deck.sort(() => Math.random() - 0.5);
                gameState.discardPile = [gameState.deck.pop()];
            }
            broadcastState();
        }

        function handleGameAction(action, peerId) {
            const currentPlayer = gameState.order[gameState.turnIndex];
            if (peerId !== currentPlayer) return; // Not your turn

            if (gameState.deck.length === 0) {
                const top = gameState.discardPile.pop();
                gameState.deck = gameState.discardPile.sort(() => Math.random() - 0.5);
                gameState.discardPile = [top];
            }

            if (action.type === 'DRAW') {
                const card = gameState.deck.pop();
                if(card) gameState.players[peerId].hand.push(card);
                nextTurn(false);
            }
            
            if (action.type === 'PLAY') {
                const cardIndex = action.index;
                const playerHand = gameState.players[peerId].hand;
                if(!playerHand[cardIndex]) return;

                const card = playerHand[cardIndex];
                const top = gameState.discardPile[gameState.discardPile.length - 1];

                if (card.color === top.color || card.value === top.value) {
                    gameState.discardPile.push(card);
                    playerHand.splice(cardIndex, 1);
                    
                    let skip = false;
                    if (card.value === 'SKIP') skip = true;
                    if (card.value === 'REV') gameState.direction *= -1;
                    if (card.value === '+2') {
                        let nextP = getNextPlayerIndex();
                        let victimId = gameState.order[nextP];
                        if (gameState.deck.length > 2) {
                            gameState.players[victimId].hand.push(gameState.deck.pop(), gameState.deck.pop());
                        }
                        skip = true; 
                    }

                    if (playerHand.length === 0) {
                        gameState.winner = peerId;
                        gameState.status = 'GAME_OVER';
                    } else {
                        nextTurn(skip);
                    }
                }
            }
            broadcastState();
        }

        function nextTurn(skip) {
            let step = gameState.direction;
            if (skip) step *= 2;
            gameState.turnIndex = (gameState.turnIndex + step) % gameState.order.length;
            if (gameState.turnIndex < 0) gameState.turnIndex += gameState.order.length;
        }

        function getNextPlayerIndex() {
            let idx = (gameState.turnIndex + gameState.direction) % gameState.order.length;
            if (idx < 0) idx += gameState.order.length;
            return idx;
        }

        function broadcastState() {
            sendState(gameState);
            if(isHost) {
                switchScreen('game');
                renderGame();
            }
        }

        // --- CLIENT UI ---
        
        window.clientDrawCard = function() {
            console.log("Attempting to draw...");
            const currentTurnId = gameState.order[gameState.turnIndex];
            if(currentTurnId !== myId) return console.log("Not my turn");
            
            const payload = { type: 'DRAW' };
            if(isHost) handleGameAction(payload, myId);
            else sendAction(payload);
        }

        window.clientPlayCard = function(index) {
            console.log(`Attempting to play card index ${index}`);
            const currentTurnId = gameState.order[gameState.turnIndex];
            if(currentTurnId !== myId) return console.log("Not my turn");

            const payload = { type: 'PLAY', index: index };
            if(isHost) handleGameAction(payload, myId);
            else sendAction(payload);
        }

        function renderGame() {
            if(gameState.status === 'GAME_OVER') {
                document.getElementById('status-msg').innerText = (gameState.winner === myId ? "ðŸ† YOU WON!" : "âŒ YOU LOST!");
                document.getElementById('table-center').classList.add('hidden');
                return;
            }

            const currentTurnId = gameState.order[gameState.turnIndex];
            const isMyTurn = (currentTurnId === myId);
            const statusDiv = document.getElementById('status-msg');
            statusDiv.innerText = isMyTurn ? "ðŸŸ¢ YOUR TURN" : `ðŸ”´ Waiting for others...`;

            // Top Card
            const topCard = gameState.discardPile[gameState.discardPile.length - 1];
            document.getElementById('discard-pile').innerHTML = '';
            const topEl = createCardElement(topCard);
            document.getElementById('discard-pile').appendChild(topEl);

            // My Hand
            const myHandDiv = document.getElementById('my-hand');
            myHandDiv.innerHTML = '';
            
            const myHand = gameState.players[myId] ? gameState.players[myId].hand : [];
            let hasValidMove = false;

            myHand.forEach((card, index) => {
                const cardEl = createCardElement(card);
                
                const isPlayable = (card.color === topCard.color || card.value === topCard.value);
                if (isPlayable) hasValidMove = true;

                if(isMyTurn && isPlayable) {
                    // *** FIX: ATTACH CLICK LISTENER TO THE ACTUAL ELEMENT ***
                    cardEl.onclick = function() { 
                        clientPlayCard(index); 
                    };
                    cardEl.style.cursor = "pointer";
                    cardEl.style.transform = "translateY(-15px)";
                    cardEl.style.zIndex = "10";
                } else {
                    cardEl.style.opacity = isMyTurn ? "0.4" : "1";
                    cardEl.style.cursor = "not-allowed";
                }
                myHandDiv.appendChild(cardEl);
            });

            // Deck Glow
            const deckEl = document.querySelector('.deck-pile');
            if (isMyTurn && !hasValidMove) {
                deckEl.style.boxShadow = "0 0 20px 5px #f1c40f";
                deckEl.style.color = "black";
                deckEl.innerText = "DRAW!";
            } else {
                deckEl.style.boxShadow = "none";
                deckEl.style.color = "transparent";
                deckEl.innerText = "UNO";
            }

            // Opponents
            const oppDiv = document.getElementById('opponents');
            oppDiv.innerHTML = '';
            gameState.order.forEach(pid => {
                if(pid === myId) return;
                const count = gameState.players[pid] ? gameState.players[pid].hand.length : 0;
                const isActive = (pid === currentTurnId);
                oppDiv.innerHTML += `
                    <div class="opponent ${isActive ? 'active' : ''}">
                        <div>Player</div>
                        <div style="font-size:20px">ðŸŽ´ ${count}</div>
                    </div>`;
            });
        }

        // Helper to create valid DOM element
        function createCardElement(card) {
            const el = document.createElement('div');
            el.className = `card ${card.color}`;
            el.innerText = card.value;
            return el;
        }
    </script>
</body>
</html>
